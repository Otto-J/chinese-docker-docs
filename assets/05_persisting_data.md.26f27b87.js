import{_ as s,c as a,o,N as n}from"./chunks/framework.dc3ff5a3.js";const l="/chinese-docker-docs/assets/items-added.44d71c60.png",A=JSON.parse('{"title":"持久化数据库","description":"Making our DB persistent in our application","frontmatter":{"title":"持久化数据库","keywords":"get started, setup, orientation, quickstart, intro, concepts, containers, docker desktop","description":"Making our DB persistent in our application"},"headers":[],"relativePath":"05_persisting_data.md"}'),p={name:"05_persisting_data.md"},e=n(`<p>如果您没有注意到，每次启动容器时，我们的待办事项列表都会被清除干净。这是为什么呢？让我们深入了解容器是如何工作的。</p><h1 id="容器的文件系统" tabindex="-1">容器的文件系统 <a class="header-anchor" href="#容器的文件系统" aria-label="Permalink to &quot;容器的文件系统&quot;">​</a></h1><p>当一个容器运行时，它使用镜像中的各个层作为其文件系统。每个容器也有自己的“临时空间”（scratch space）来创建/更新/删除文件。任何更改都不会在另一个容器中看到，即使它们使用相同的镜像。</p><h2 id="在实践中看到这一点" tabindex="-1">在实践中看到这一点 <a class="header-anchor" href="#在实践中看到这一点" aria-label="Permalink to &quot;在实践中看到这一点&quot;">​</a></h2><p>为了看到这一点，我们将启动两个容器并在每个容器中创建一个文件。您将看到在一个容器中创建的文件在另一个容器中不可用。</p><ol><li><p>启动一个 <code>ubuntu</code> 容器，它将创建一个名为 <code>/data.txt</code> 的文件，随机数在 1 到 10000 之间。</p><div class="language-console"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-d</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ubuntu</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">bash</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-c</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div><p>如果您对该命令感到好奇，这里做个解释：我们将启动一个 bash shell 并调用两个命令（为什么我们有 <code>&amp;&amp;</code>）。第一部分选择一个随机数并将其写入 <code>/data.txt</code>.第二个命令只是观察一个文件以保持容器运行。</p></li><li><p>验证您是否可以通过访问容器中的终端来查看输出。为此，请转到 Docker Desktop 中的 <strong>容器 Containers</strong> ，将鼠标悬停在运行 <code>ubuntu</code> 镜像的容器上，然后选择<strong>显示容器操作 Show container actions</strong>菜单。从下拉框中，选择 <strong>在终端中打开 Open in terminal</strong>。</p><p>您将看到一个终端正在 Ubuntu 容器中运行 shell。运行以下命令以查看 /<code>data.txt</code> 文件的内容。之后再次关闭此终端。</p><div class="language-console"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">cat</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/data.txt</span></span>
<span class="line"></span></code></pre></div><p>如果您更喜欢命令行，您可以使用 <code>docker exec</code> 命令来执行相同的操作。您需要获取容器的 ID（使用 <code>docker ps</code> 获取）并使用以下命令获取内容。</p><div class="language-console"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">exec</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">container-i</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">cat</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/data.txt</span></span>
<span class="line"></span></code></pre></div><p>你应该看到一个随机数字！</p></li><li><p>现在，让我们启动另一个 <code>ubuntu</code> 容器（相同的镜像），我们会看到我们没有相同的文件。</p><div class="language-console"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-it</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ubuntu</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ls</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/</span></span>
<span class="line"></span></code></pre></div><p>看！那里没有 <code>data.txt</code> 文件！那是因为它仅被写入第一个容器的暂存空间。</p></li><li><p>继续使用 <code>docker rm -f &lt;container-id&gt;</code> 命令删除第一个容器。</p></li></ol><h2 id="容器数据卷" tabindex="-1">容器数据卷 <a class="header-anchor" href="#容器数据卷" aria-label="Permalink to &quot;容器数据卷&quot;">​</a></h2><p>在前面的实验中，我们看到每个容器每次启动时都从镜像定义开始。虽然容器可以创建、更新和删除文件，但当容器被删除并且所有更改都隔离到该容器时，这些更改会丢失。有了数据卷，我们可以改变这一切。</p><p><a href="./../storage/volumes.html">数据卷 Volumes</a>提供了将容器的特定文件系统路径连接回主机的能力。如果容器中的目录被挂载，该目录中的更改也会在主机上看到。如果我们在容器重新启动时挂载相同的目录，我们会看到相同的文件。</p><p>卷有两种主要类型。我们最终会同时使用两者，但我们将从卷挂载开始。</p><h2 id="保留待办事项数据" tabindex="-1">保留待办事项数据 <a class="header-anchor" href="#保留待办事项数据" aria-label="Permalink to &quot;保留待办事项数据&quot;">​</a></h2><p>默认情况下，todo 应用程序将其数据存储在容器文件系统中 <code>/etc/todos/todo.db</code> 的 SQLite 数据库中。如果您不熟悉 SQLite，不用担心！它只是一个关系数据库，其中所有数据都存储在一个文件中。虽然这对于大型应用程序来说不是最好的，但它适用于小型演示。稍后我们将讨论将其切换到不同的数据库引擎。</p><p>由于数据库是单个文件，如果我们可以在主机上持久化该文件并使其可用于下一个容器，它应该能够从最后一个停止的地方继续。通过创建一个卷并将其附加（通常称为“挂载”）到存储数据的目录，我们可以持久化数据。当我们的容器写入 <code>todo.db</code> 文件时，它将持久化到卷中的主机。</p><p>如前所述，我们将使用卷挂载。将卷挂载视为不透明的数据桶。Docker 完全管理卷，包括它存储在磁盘上的位置。您只需要记住卷的名称。</p><ol><li><p>使用 <code>docker volume create</code> 命令创建卷。</p><div class="language-console"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">volume</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">create</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">todo-db</span></span>
<span class="line"></span></code></pre></div></li><li><p>在仪表板中再次停止并删除待办事项应用容器（或使用 <code>docker rm -f &lt;id&gt;</code>），因为它仍在运行而不使用持久卷。</p></li><li><p>启动待办事项应用程序容器，但添加 <code>--mount</code> 选项以指定卷挂载。我们将为卷命名，并将其挂载到容器中的 <code>/etc/todos</code>，这将捕获在路径上创建的所有文件。</p><div class="language-console"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-dp</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3000</span><span style="color:#C3E88D;">:</span><span style="color:#F78C6C;">3000</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--mount</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">type=volume,src=todo-db,target=/etc/todos</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">getting-started</span></span>
<span class="line"></span></code></pre></div></li><li><p>容器启动后，打开应用程序并将一些项目添加到您的待办事项列表中。</p><p><img src="`+l+`" alt="Items added to todo list"></p></li><li><p>停止并删除待办事项应用程序的容器。使用仪表板或 <code>docker ps</code> 获取 ID，然后 <code>docker rm -f &lt;id&gt;</code> 将其删除。</p></li><li><p>使用上面的相同命令启动一个新容器。</p></li><li><p>打开应用程序。您应该会看到您的物品仍在您的列表中！</p></li><li><p>完成对列表的签出后，请继续并移除容器。</p></li></ol><p>恭喜！您现在已经学会了如何持久化数据！</p><h2 id="深入理解-volume" tabindex="-1">深入理解 volume <a class="header-anchor" href="#深入理解-volume" aria-label="Permalink to &quot;深入理解 volume&quot;">​</a></h2><p>很多人经常问“当我使用卷时，Docker 将我的数据存储在哪里？”如果你想知道，你可以使用 <code>docker volume inspect</code> 命令。</p><div class="language-console"><button title="Copy Code" class="copy"></button><span class="lang">console</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">$</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">volume</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">inspect</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">todo-db</span></span>
<span class="line"><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">    {</span></span>
<span class="line"><span style="color:#89DDFF;">        &quot;</span><span style="color:#C3E88D;">CreatedAt</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">:</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">2019-09-26T02:18:36Z</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"><span style="color:#89DDFF;">        &quot;</span><span style="color:#C3E88D;">Driver</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">:</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">local</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"><span style="color:#89DDFF;">        &quot;</span><span style="color:#C3E88D;">Labels</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: {},</span></span>
<span class="line"><span style="color:#89DDFF;">        &quot;</span><span style="color:#C3E88D;">Mountpoint</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">:</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">/var/lib/docker/volumes/todo-db/_data</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"><span style="color:#89DDFF;">        &quot;</span><span style="color:#C3E88D;">Name</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">:</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">todo-db</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"><span style="color:#89DDFF;">        &quot;</span><span style="color:#C3E88D;">Options</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: {},</span></span>
<span class="line"><span style="color:#89DDFF;">        &quot;</span><span style="color:#C3E88D;">Scope</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">:</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">local</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#89DDFF;">]</span></span>
<span class="line"></span></code></pre></div><p><code>挂载点Mountpoint</code> 是磁盘上存储数据的实际位置。请注意，在大多数机器上，您需要具有 root 访问权限才能从主机访问此目录。但是，这就是它所在的位置！</p><blockquote><p><strong>直接在 Docker Desktop 上访问卷数据</strong></p><p>在 Docker Desktop 中运行时，Docker 命令实际上是在您机器上的小型 VM 中运行的。如果您想查看挂载点目录的实际内容，则需要查看该 VM 的内部。</p></blockquote><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><p>在这一点上，你有一个功能正常的应用程序，可以在重启中幸存下来！你可以向你的投资者展示它，希望他们能抓住你的愿景！</p><p>但是，您之前看到为每次更改重建镜像需要相当多的时间。一定有更好的方法来进行更改，对吧？使用挂在绑定（之前暗示过），有更好的方法！</p><p><a href="./06_bind_mounts.html">Use bind mounts</a></p>`,25),t=[e];function c(r,i,d,C,D,y){return o(),a("div",null,t)}const F=s(p,[["render",c]]);export{A as __pageData,F as default};
